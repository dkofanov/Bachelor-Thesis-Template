\chapter{Сравнение подходов к проблеме платформо-зависимых констант}
\label{sec:Chapter2} \index{Chapter2}

В этой главе описываются два подхода к решению проблемы платформо-зависимых величин -- фиксирование величин между всеми платформами и, контрастное ему, вычисление величин для каждой платформы, а также производится сравнение этих подходов. Хочется отметить, что данная работа посвящена последнему из них, а так же что её возникновение обязано успешной попытке устранить недостатки, связанные с первым подходом.

\section{Фиксирование констант}
Этот подход заключается в поддержании кода в таком состоянии, при котором величины будут иметь одно и то же значение на каждой из платформ.
Из достоинств данного подхода можно отметить простоту идеи, однако на практике, следование такому подходу сопровождается нетривиальными сложностями.
\par
Например, к этому может привести использование атрибутов, не относящихся к стандарту языка.
При использовании разных тулчейнов, хотя и относящихся к одной и той же платформе (например GCC и LLVM), может получаться отличающийся результат.
\par
Далее, остаётся открытым вопрос самого фиксирования этих величин: ранее был рассмотрен лишь один из примеров -- смещения полей в структуре данных, однако фиксирование величин другой природы может быть связано со значительными сложностями, если будет возможно в принципе.
\par
Кроме этого, для верификации, каждой константе должна соответствовать статическая проверка на то, что текущее значение велчичины действительно совпадает с некоторым жёстко закодированным числом.
Из-за этого, исходный код проекта приобретает избыточную и малоинформативную логику, необходимую лишь для проверки корректности самого подхода, причём на фоне большого числа таких констант сложно гарантировать существование такой проверки для каждой из них.
Более того, при активной разработке и модификации виртуальной машины, фактические значения констант могут меняться (что можно легко проследить на примере изменения смещений при добавлении нового поля в структуру), инициируя необходимость модификации уже существующих проверок.
Разработчик неизбежно будет сталкиваться с последствиями такого подхода, поддержка проекта будет становиться всё сложнее.

\section{Вычисление констант}

Альтернативой является более консервативный подход, описываемый как вычисление величин для каждой платформы, который имплементирован в ходе данной работы.
Под консервативностью следует понимать отсутствие каких-либо требований и ограничений на значения констант, описанных ранее, и отсутствие вмешательств в исходный код, связанных с этими ограничениями. Хотя на первый взгляд способ вычисления "гостевых" значений кажется неочевидным, предположив что он существует, множество описанных ранее проблем устраняются сами собой или вовсе лишены смысла.

\par
Так, не появляются затруднения при использовании платформо-зависимого функционала какого-либо тулчейна.
Также, не приходится изобретать способ фиксирования для констант разного происхождения, что делает такой подход более однородным и гибким.
Не возникает и вопроса сверки констант на разных платформах, так как допускается их различие.
Это в свою очередь допускает решения, являющимися локально оптимальными для каждой из платформ.
Например, рассмотрим структуру данных с двумя указателями. Выравнивание на 8 байт на некой 32-битной архитектуре будет связано с накладными расходами на размер используемой памяти, в то время как выравнивание на 4 байта может повлечь снижение производительности на 64-битной платформе.
Данный подход позволяет использовать 4-байтное выравнивание на 32-битной платформе и 8-байтное выравнивание на 64-битной платформе для одной и той же структуры данных.

\par
Таким образом, этот подход, а именно отказ от "модификации" констант, устраняет большинство, если не все, недостатки, описанные в предыдущей секции.
С другой стороны, формально он допускает раннее описанный подход, то есть в определённом смысле не противоречит ему: значения каждой из величин на всех платформах могут (искусственно или естественно) совпасть.
С практической точки зрения, это означает, что миграция с использования первого подхода на использование второго может происходить поэтапно, то есть сначала можно наладить инфраструктурную часть, а затем, по мере необходимости, ослаблять введённые искусственно ограничения.

\par
Важно сделать следующее замечание.
Необходимо, чтобы полученный кросс-компилятором, расчитывающим на какую-то конкретную платформу, код действительно запускался в контексте виртуальной машины, собранной для той же платформы.
В описываемой ниже имплементации эта проблема устраняется путём вычисления контрольной суммы CRC32 из значений констант на таргет-платформе и последующей её записи как в каждый AOT-файл, генерируемый кросс-компилятором виртуальной машины, так и в сам таргет-образ виртуальной машины.
Во время инсталяции AOT-файла происходит сверка этих значений, что позволяет обнаружить потенциальные ошибки, связанные с несовместимостью между кросс-скомпилированным кодом и самой виртуальной машиной.
Однако в таком виде, эта особенность не является недостатком.
Действительно, значение какой-либо константы может изменяться в зависимости от версии виртуальной машины, а совпадение версии кросс-компилятора, находящегося на сервере, и самой виртуальной машины, находящейся на устройстве, при ошибках инфраструктуры может нарушиться.
Такая контрольная сумма вносит дополнительную степень верификации, косвенно проверяя совместимость версий и несёт дополнительную полезную нагрузку, никак не связанную с выбранным подходом. 

\section{Итог сравнения}
Исходя из вышесказанного, второй подход, связанный с вычислением констант для каждой платформы, является более предпочтительным в виду своей универсальности.
Характерная ему однородность, определённая выше, позволяет в высокой степени автоматизировать весь процесс, связанный с вычислением значений и поддержанием их в консистентном состоянии (как в случае чистой, так и инкрементальной сборки), фактически отделяясь в независимый инкапсулирующий модуль.
Разработчик сталкивается с этим модулем лишь через интерфейс и у него нет необходимости вручную вносить изменения в этот модуль: достаточно лишь определения платформо-зависимой константы, после чего её можно использовать в основной части проекта.

\par
Дальнейшее повествование раскрывает детали реализации выбранного подхода.
 
\newpage