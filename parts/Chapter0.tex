\chapter{Введение}
\label{sec:Chapter0} \index{Chapter0}

На момент написания этой работы сложно переоценить влияние мобильных устройств на повседневную жизнь.
Смартфоны предоставляют огромный спектр возможностей, начиная от коммуникации и игр, заканчивая рабочими потребностями, навигацией и отслеживанием физического состояния человека.
Количество использующихся телефонов значительно преобладает над количеством ПК и ноутбуков.
Однако такой массовый характер был бы невозможен в отсутствии многообразия устройств на рынке.
Действительно, развитие технологий безусловно исходит из потребности в новых возможностях, однако финансирование этого развития поступает из уже существующих и отлаженных технологий.
Кроме того, только что изобретённой технологии требуется некоторое время, чтобы спрос на неё появился и вырос.
Исходя из этого, а также готовности потребителя пойти на компромисс между ценой за устройство и количеством и качеством предоставляемых им функций, представленные на рынке устройства коренным образом отличаются между собой.

\par
С другой стороны, имея такое разнообразие, разрабатывать приложения и отлаживать под каждое устройство было бы слишком дорогой задачей.
Чтобы решить эту проблему, вводится понятие виртуальной машины, то есть некоторого абстрактного вычислителя, способного исполнять инструкции из определённого набора, тем самым обеспечивая разработчиков приложений некоторым количеством гарантий.
Кажется очевидным, что этот подход аналогичен договорённости между программистами и разработчиками микропроцессоров в виде архитектуры системы команд и почти в той же степени необходим.
Главное отличие заключается в более высоком уровне абстракции, что позволяет переложить ответственность за управление ресурсами приложения, например выделение и освобождение памяти, на саму виртуальную машину, тем самым упрощая код и снижая требовательность к опыту разработчика.
В случае мобильных устройств, виртуальная машина рассматривается практически как неотъемлимая часть операционной системы, которая, помимо обеспечения гарантий разработчикам приложений, служит барьером безопасности для пользователей, устанавливающих и использующих самые разные приложения. 

\par
Высокоуровневость виртуальных машин позволяет выражать программы более компактно в сравнении с выражением в нативном коде.
В то же время, поочерёдное исполнение инструкций виртуальной машины (интерпретация байткода) существенно замедляет алгоритм.
Выходом из этой ситуации стало использование just-in-time компиляции, то есть генерация оптимизированного нативного кода для часто вызываемых функций, происходящая параллельно выполнению основного алгоритма.
Использование как классических оптимизаций, например межпроцедурной оптимизации, раскрутки циклов, так и специфичных JIT-оптимизаций, например профилирование типов в случае динамических языков, позволяет достичь производительности, нивелирующей накладные расходы вносимые этим уровнем абстракции.
В виртуальных машинах так же используется ahead-of-time компиляция, производящаяся до запуска приложения.
Это позволяет избежать излишних затрат энергии при повторных запусках приложений связанных с JIT-компиляцией, скомпилировать большее количество методов, и, возможно, применить большее количество оптимизаций, тем самым экономя заряд батареи мобильных устройств, ускоряя время запуска и улучшая производительность приложения за счёт хранения результатов компиляции (AOT-файлов) на устройстве.

\par
Очевиден тот факт, что множество приложений в своих подзадачах часто используют идентичные алгоритмы, такие как сортировка, работа со строками и т. д., и что множественная имплементация того или иного алгоритма ведёт к практической сложности поддержки такого кода.
В виду этого, многие алгоритмы, оптимизированные с целью быть приемлимо эффективными для самых различных нагрузок, образуют стандартную библиотеку языка и поставляются вместе с виртуальной машиной.
Будучи часто переиспользуемой, стандартная библиотека AOT-компилируется и хранится на устройстве, что позволяет любому приложению гарантировано использовать оптимизированный нативный код, не совершая излишнюю работу по JIT-компиляции.

\par
Выпуская огромное количество устройств, запускать AOT-компиляцию стандартной библиотеки на каждом из них было бы нерационально для производителя и сопровождалось бы ощутимыми издержками производства.
Их можно избежать путём единовременной компиляции и последующей загрузки полученного образа на устройства, например при прошивке.
Для подготовки образа виртуальной машины и операционной системы используется специальный набор утилит, включающий в себя кросс-компилятор и опции компиляции, который работает на отличной от целевого устройства платформе и генерирующий исполняемые файлы в виде нативного кода целевого устройства.
Для такого набора утилит принят термин таргет-тулчейн, в то время как аналогичный набор утилит, предназначенный для получения исполняемых файлов, нативных для той же платформы на которой они и были сгенерированы, обозначается как хост-тулчейн.

\par
Однако, таргет-тулчейн не подходит для непосредственной подготовки AOT-файла стандартной библиотеки.
Это связано с тем, что стандартная библиотека расчитана на исполнение в среде виртуальной машины, отличающейся от окружения создаваемого операционной системой и может проявляться в том, что тулчейн-компилятор и AOT-компилятор виртуальной машины могут использовать разное соглашение о вызовах.
В виду этого появляется вопрос о кросс-компиляторе в терминах виртуальной машины, что на самом деле означает возможность генерации AOT-файлов виртуальной машины для определённого устройства на другой платформе, например на сервере. Эта задача имеет множество тонкостей, одной из которых посвящена данная работа - проблема зависимости некоторых численных значений от платформы (платформо-зависимых констант). Наиболее ярким примером является размер указателя. Однако в этом случае зависимость от платформы достаточно легко <<предсказать>>: на AMD64-совместимой платформе это скорее всего 64 бита, а на ARM32 - 32. Другим, более трудноразрешимым и содержательным примером является смещение до полей в структурах данных. Будучи собранным на одной и той же платформе одним и тем же компилятором, в заисимости от опций компиляции результат может быть различным. В последующих главах излагается подробное описание этой проблемы, на примере абстрактной виртуальной машины демонстрируется один из источников таких значений, а также предлагается решение, основанное на использовании таргет-тулчейна, нашедшее применение в виртуальной машине ArkCompiler. Как будет показано в дальнейшем, эта имплементация отличается высоким уровнем автоматизации и масштабируемости, делающей её малозаметной и лёгкой в использовании. Кроме того, помимо основной функции, она вносит дополнительную степень верифицикации AOT-файлов.

\newpage